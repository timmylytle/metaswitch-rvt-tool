package com.Metaswitch.MVS.Corba;


/**
* com/Metaswitch/MVS/Corba/SettingsUserInterface.java .
* Generated by the IDL-to-Java compiler (portable), version "3.2"
* from SettingsUserInterface.idl
* Thursday, June 18, 2020 8:33:03 PM CDT
*/


/**
 * The SettingsUserInterface provides the client application with methods to:
 * enumerate fields; obtain detailed type information that describes each of
 * the fields including ranges, units and default values; get and set field
 * values; query lists of possible values for fields.
 */
public interface SettingsUserInterface extends SettingsUserInterfaceOperations, org.omg.CORBA.Object, org.omg.CORBA.portable.IDLEntity 
{

  /**
       * 32-bit integer field.
       */
  public static final int TYPE_INT32 = (int)(1);

  /**
       * 64-bit integer.
       */
  public static final int TYPE_INT64 = (int)(2);

  /**
       * String field.
       */
  public static final int TYPE_STRING = (int)(3);

  /**
       * Boolean field.
       */
  public static final int TYPE_BOOLEAN = (int)(4);

  /**
       * 32-bit integer field with a specified range.
       */
  public static final int TYPE_INT32_RANGE = (int)(5);

  /**
       * Array of 32-bit integers field.
       */
  public static final int TYPE_INT32_ARRAY = (int)(6);

  /**
       * 32-bit integer field with a specified set of values: a 'one of' field.
       */
  public static final int TYPE_INT32_MAP = (int)(7);

  /**
       * Array of octets field.
       */
  public static final int TYPE_BYTE_ARRAY = (int)(8);

  /**
       * 32-bit integer bit mask field.
       */
  public static final int TYPE_BIT_MASK = (int)(9);

  /**
       * Unsigned 64-bit integer (unsigned long) field.
       */
  public static final int TYPE_UNSIGNED_LONG = (int)(10);

  /**
       * 64-bit integer field with a specified range.
       */
  public static final int TYPE_LONG_RANGE = (int)(11);

  /**
       * If the field is of an integer type, then it is written as a signed
       * decimal.  If the field is of TYPE_BYTE_ARRAY then it is written as a
       * series of hex strings, with each byte corresponding to 2 hex characters.
       * There are spaces between bytes e.g.  "FF FF FF".
       */
  public static final int FORMAT_DEFAULT = (int)(0);

  /**
       * Written as a hexadecimal string preceded by "0x" or "0X".
       */
  public static final int FORMAT_HEX = (int)(1);

  /**
       * Written as an unsigned decimal.
       */
  public static final int FORMAT_UNSIGNED = (int)(2);

  /**
       * Written in IP address format e.g. "255. 255. 255. 255".
       */
  public static final int FORMAT_4_BYTE_DOTTED_DEC = (int)(3);

  /**
       * Written in pointcode format e.g. "255-255-255".
       */
  public static final int FORMAT_3_BYTE_DASHED_DEC = (int)(4);

  /**
       * Written as an ASCII string where each byte corresponds to an
       * ASCII character.  Applies to fields of TYPE_BYTE_ARRAY only.
       */
  public static final int FORMAT_ASCII = (int)(5);

  /**
       * Writes as plain text only.  Applies to fields of TYPE_STRING only.
       */
  public static final int FORMAT_BODY_TEXT = (int)(6);

  /**
       * Write the string highlighted to mark the text as a header.
       * Applies to fields of TYPE_STRING only.
       */
  public static final int FORMAT_HEADING = (int)(7);

  /**
       * This indicates that the value is a time in UTC format - specifying the
       * seconds since 00:00:00 1 Jan 1970 if it is 32-bit or the milliseconds
       * since 00:00:00 1 Jan 1970 if it is 64-bit.
       * Written as UTC time e.g. "00:00:00 1 Jan 1970". Fields with this format
       * treat integer values as implicitly unsigned.
       */
  public static final int FORMAT_TIMESTAMP = (int)(8);

  /**
       * Written as a 64-bit unsigned hexadecimal string split into four lots of
       * four characters e.g. "FFFF FFFF FFFF FFFF". This is not applicable for
       * 32-bit quantities.  Fields with this format treat integer values as
       * implicitly unsigned.
       */
  public static final int FORMAT_LOG_CORRELATOR = (int)(9);

  /**
       * This indicates that the value is a Version Level version number.  The
       * value is written in the form Vx.y.z where x, y and z are integers
       * between 0 and 255.  y and z are padded with 1 leading zero if they are 1
       * digit in length.  If y is two digits long and ends with a zero, this
       * zero is stripped.  e.g.  for V1.04, the version is:
       *
       * -  stored as: 0x01040000
       * -  written as: V1.04.00
       */
  public static final int FORMAT_VERSION_LEVEL = (int)(10);

  /**
       * This indicates that the value is a Service Level version number.  The
       * value is written in the form SUx Py.z where x, y and z are integers
       * between 0 and 255.  z is padded with 1 leading zero if it is 1 digit in
       * length.  e.g.  for Update 5 Patch 6.7, the version is:
       *
       * -  stored as: 0x05060700
       * -  written as: SU5 P6.07
       */
  public static final int FORMAT_SERVICE_LEVEL = (int)(11);

  /**
       * This indicates that the value is a Boot Level version number.  The
       * value is written in the form Bx Py.z where x, y and z are integers
       * between 0 and 255.  z is padded with 1 leading zero if it is 1
       * digit in length.  e.g.  for 9 Patch 10.11, the version is:
       *
       * -  stored as: 0x090A1100
       * -  written as: B9 P10.11
       */
  public static final int FORMAT_BOOT_LEVEL = (int)(12);

  /**
       * This indicates that the value is an array of decimal integers, each
       * separated by a single dot.
       */
  public static final int FORMAT_OID = (int)(13);

  /**
       * This indicates that the value is an IP address e.g.  "255.255.255.255".
       */
  public static final int FORMAT_IP_ADDRESS_V4 = (int)(14);

  /**
       * Write the string highlighted to mark the text as a header at a level
       * below that of FORMAT_HEADING.  Applies to fields of TYPE_STRING only.
       */
  public static final int FORMAT_MINOR_HEADING = (int)(15);

  /**
       * Written as an ASCII string on multiple lines where each byte corresponds
       * to an ASCII character.  The value should ideally be displayed in a fixed
       * width font, with no wrapping. Applies to fields of TYPE_BYTE_ARRAY only.
       */
  public static final int FORMAT_ASCII_MULTI_FIXED_NOWRAP = (int)(16);

  /**
       * Written as an ASCII string on multiple lines where each byte corresponds
       * to an ASCII character.  The value should ideally be displayed in a
       * standard, non-fixed width font, with wrapping. Applies to fields
       * of TYPE_BYTE_ARRAY only.
       */
  public static final int FORMAT_ASCII_MULTI_VAR_WRAPPED = (int)(17);

  /**
       * This indicates that the value is an EMS Boot Level version number.  The
       * value is written in the form EMSx where x is an integer between 0 and
       * 255.  x is padded with leading zeros to make it 3 digits in length.
       * e.g.  for boot level 13, the version is:
       *
       * -  stored as: 0x0D000000
       * -  written as: EMS013
       */
  public static final int FORMAT_EMS_BOOT_LEVEL = (int)(18);

  /**
       * This indicates that the value is displayed as a four digit integer.
       * This means that a number will be padded with leading zeros as necessary.
       */
  public static final int FORMAT_4_DIGIT_INT = (int)(19);

  /**
       * Write the string highlighted to mark the text as a header.  Field group
       * headers act as the heading of a group of similar fields, e.g.  alarm
       * fields.  Applies to fields of TYPE_STRING only.
       */
  public static final int FORMAT_FIELD_GROUP_HEADING = (int)(20);

  /**
       * Display a byte or int32 as a graph where each value in the array
       * corresponds to a point on the graph.
       */
  public static final int FORMAT_GRAPH = (int)(21);

  /**
       * This indicates that the value represents a PKCS12 key store.
       **/
  public static final int FORMAT_PKCS12 = (int)(22);

  /**
       * This indicates that the field offers a choice of integers.  Applies to
       * fields of TYPE_STRING only.
       **/
  public static final int FORMAT_CHOICE_OF_INTEGERS = (int)(23);

  /**
       * This indicates that the value is displayed as a two digit integer.
       * This means that a number will be padded with leading zeros as necessary.
       */
  public static final int FORMAT_2_DIGIT_INT = (int)(24);

  /**
       * This indicates that the value is an IP address, and can be in either the
       * IPV4, or the IPV6 format (xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx), or
       * the IPV4/IPV6 hybrid format.
       */
  public static final int FORMAT_IP_ADDRESS_V4_OR_V6 = (int)(25);

  /**
       * This indicates that the value is an IP address, and can only be in the
       * the IPV6 format (xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx), or the IPV4/
       * IPV6 hybrid format.
       */
  public static final int FORMAT_IP_ADDRESS_V6 = (int)(26);

  /**
       * Written as a unicode string in UTF-8 format.
       * Applies to fields of TYPE_BYTE_ARRAY only.
       */
  public static final int FORMAT_UTF8 = (int)(27);

  /**
       * Written as a unicode string in UTF-8 format on multiple lines.
       * The value should ideally be displayed in a fixed width font, with no
       * wrapping. Applies to fields of TYPE_BYTE_ARRAY only.
       */
  public static final int FORMAT_UTF8_MULTI_FIXED_NOWRAP = (int)(28);

  /**
       * Written as a unicode string in UTF-8 format on multiple lines.
       * The value should ideally be displayed in a standard, non-fixed width
       * font, with wrapping. Applies to fields of TYPE_BYTE_ARRAY only.
       */
  public static final int FORMAT_UTF8_MULTI_VAR_WRAPPED = (int)(29);

  /**
       * Written as a true ASCII string (no Latin-1 characters) where each byte
       * corresponds to an ASCII character.  Applies to fields of TYPE_BYTE_ARRAY
       * only.
       */
  public static final int FORMAT_STRICT_ASCII = (int)(30);

  /**
       * Written as a true ASCII string (no Latin-1 characters) on multiple lines
       * where each byte corresponds to an ASCII character.  The value should
       * ideally be displayed in a fixed width font, with no wrapping. Applies to
       * fields of TYPE_BYTE_ARRAY only.
       */
  public static final int FORMAT_STRICT_ASCII_MULTI_FIXED_NOWRAP = (int)(31);

  /**
       * Written as a true ASCII string (no Latin-1 characters) on multiple lines
       * where each byte corresponds to an ASCII character.  The value should
       * ideally be displayed in a standard, non-fixed width font, with wrapping.
       * Applies to fields of TYPE_BYTE_ARRAY only.
       */
  public static final int FORMAT_STRICT_ASCII_MULTI_VAR_WRAPPED = (int)(32);

  /**
       * Written as a domain name string, specified as a series of valid
       * (alphanumeric, hyphen or period) characters or a space, not a mix of
       * both.  The string is in ASCII format and it is assumed that Unicode
       * strings have been converted to IDNA format.  For our purposes, spaces
       * should not be included because we do not want to define a domain name as
       * a space character.
       * Applies to fields of TYPE_BYTE_ARRAY only.
       */
  public static final int FORMAT_DOMAIN_NAME_IDNA = (int)(33);

  /**
       * This indicates that the value is an IP address, and can be in either the
       * IPV4, or the IPV6 format (xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx), or
       * the IPV4/IPV6 hybrid format, but IPv6 support is disabled, so its
       * value can be only IPV4. This way, this field should be treated by the
       * client exactly as if the field had the format FORMAT_IP_ADDRESS_V4
       */
  public static final int FORMAT_IP_ADDRESS_V4_ENABLED_V6_DISABLED = (int)(34);

  /**
       * This indicates that the field offers a choice of resources.  Applies to
       * fields of TYPE_STRING only.
       **/
  public static final int FORMAT_CHOICE_OF_RESOURCES = (int)(35);

  /**
       * Written as a unicode string in UTF-8 format on multiple lines.
       * The value should ideally be displayed in a fixed width font, with no
       * wrapping. Applies to fields of TYPE_BYTE_ARRAY only.
       * This format is identical to FORMAT_UTF8_MULTI_FIXED_NOWRAP_LONG,
       * except that it should be displayed with a large number of lines by
       * default.
       */
  public static final int FORMAT_UTF8_MULTI_FIXED_NOWRAP_LONG = (int)(36);

  /**
       * Initial SE state before creation is complete.  An SE is only in this
       * state after an attachToNew invocation, not an attachTo.  The SE leaves
       * this state when the first doAction(APPLY) complete successfully.  The
       * index fields may be writeable.
       */
  public static final int STATE_CREATING = (int)(0x03);

  /**
       * The SE is fully created and so the index fields are always
       * read only in this state.  The state cannot return to STATE_CREATING.
       * STATE_DISABLED is a lower state of activation that STATE_ENABLED.
       */
  public static final int STATE_DISABLED = (int)(0x0c);

  /**
       * The SE is fully created and so the index fields are always
       * read only in this state.  The state cannot return to STATE_CREATING.
       * This is the highest state of activation.
       */
  public static final int STATE_ENABLED = (int)(0x30);
} // interface SettingsUserInterface
